<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"></head><body>"Fourth International Workshop on Mining Software Repositories - Cover," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. c1-c1.<br>doi: 10.1109/MSR.2007.11<br>Abstract: The following topics are dealt with: program debugging; data mining; software repository; software development.<br> keywords: {data mining;software engineering;data mining;program debugging;software development;software repository},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228636&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228636&amp;isnumber=4228635</a><br><br>"Fourth International Workshop on Mining Software Repositories - TOC," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. v-v.<br>doi: 10.1109/MSR.2007.12<br>Abstract: Presents the table of contents of the proceedings.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228637&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228637&amp;isnumber=4228635</a><br><br>C. Weiss, R. Premraj, T. Zimmermann and A. Zeller, "How Long Will It Take to Fix This Bug?," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 1-1.<br>doi: 10.1109/MSR.2007.13<br>Abstract:
 Predicting the time and effort for a software problem has long been a 
difficult task. We present an approach that automatically predicts the 
fixing effort, i.e., the person-hours spent on fixing an issue. Our 
technique leverages existing issue tracking systems: given a new issue 
report, we use the Lucene framework to search for similar, earlier 
reports and use their average time as a prediction. Our approach thus 
allows for early effort estimation, helping in assigning issues and 
scheduling stable releases. We evaluated our approach using effort data 
from the JBoss project. Given a sufficient number of issues reports, our
 automatic predictions are close to the actual effort; for issues that 
are bugs, we are off by only one hour, beating naive predictions by a 
factor of four.<br> keywords: {program debugging;JBoss project;Lucene 
framework;issue tracking system;program debugging;software bugs 
prediction;stable release scheduling;Computer 
bugs;Costs;Debugging;History;Programming;Project 
management;Scheduling;Spatial databases},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228638&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228638&amp;isnumber=4228635</a><br><br>J. Anvik and G. C. Murphy, "Determining Implementation Expertise from Bug Reports," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 2-2.<br>doi: 10.1109/MSR.2007.7<br>Abstract:
 As developers work on a software product they accumulate expertise, 
including expertise about the code base of the software product. We call
 this type of expertise 'implementation expertise'. Knowing the set of 
developers who have implementation expertise for a software product has 
many important uses. This paper presents an empirical evaluation of two 
approaches to determining implementation expertise from the data in 
source and bug repositories. The expertise sets created by the 
approaches are compared to those provided by experts and evaluated using
 the measures of precision and recall. We found that both approaches are
 good at finding all of the appropriate developers, although they vary 
in how many false positives are returned.<br> keywords: {program 
debugging;software engineering;bug report;software product;software 
repository;source code;Computer bugs;Couplings;Software 
engineering;Software systems},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228639&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228639&amp;isnumber=4228635</a><br><br>S.
 Morisaki, A. Monden, T. Matsumura, H. Tamada and K. i. Matsumoto, 
"Defect Data Analysis Based on Extended Association Rule Mining," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 3-3.<br>doi: 10.1109/MSR.2007.5<br>Abstract:
 This paper describes an empirical study to reveal rules associated with
 defect correction effort. We defined defect correction effort as a 
quantitative (ratio scale) variable, and extended conventional (nominal 
scale based) association rule mining to directly handle such 
quantitative variables. An extended rule describes the statistical 
characteristic of a ratio or interval scale variable in the consequent 
part of the rule by its mean value and standard deviation so that 
conditions producing distinctive statistics can be discovered As an 
analysis target, we collected various attributes of about 1,200 defects 
found in a typical medium-scale, multi-vendor (distance development) 
information system development project in Japan. Our findings based on 
extracted rules include: (l)Defects detected in coding/unit testing were
 easily corrected (less than 7% of mean effort) when they are related to
 data output or validation of input data. (2)Nevertheless, they 
sometimes required much more effort (lift of standard deviation was 
5.845) in case of low reproducibility, (i)Defects introduced in 
coding/unit testing often required large correction effort (mean was 
12.596 staff-hours and standard deviation was 25.716) when they were 
related to data handing. From these findings, we confirmed that we need 
to pay attention to types of defects having large mean effort as well as
 those having large standard deviation of effort since such defects 
sometimes cause excess effort.<br> keywords: {data analysis;data 
mining;program debugging;program testing;statistical 
analysis;association rule mining;data handing;defect data 
analysis;information system development project;standard 
deviation;statistical characteristics;unit testing;Association 
rules;Data analysis;Data mining;Information analysis;Information 
science;Information systems;Risk management;Software 
engineering;Statistics;Testing},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228640&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228640&amp;isnumber=4228635</a><br><br>O. Mizuno, S. Ikami, S. Nakaichi and T. Kikuno, "Spam Filter Based Approach for Finding Fault-Prone Software Modules," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 4-4.<br>doi: 10.1109/MSR.2007.29<br>Abstract:
 Because of the increase of needs for spam e-mail detection, the spam 
filtering technique has been improved as a convenient and effective 
technique for text mining. We propose a novel approach to detect 
fault-prone modules in a way that the source code modules are considered
 as text files and are applied to the spam filter directly. In order to 
show the applicability of our approach, we conducted experimental 
applications using source code repositories of Java based open source 
developments. The result of experiments shows that our approach can 
classify more than 75% of software modules correctly.<br> keywords: 
{data mining;information filtering;information filters;program 
diagnostics;software fault tolerance;software quality;unsolicited 
e-mail;e-mail detection;fault-prone software module;source code 
module;spam filter based approach;text mining;Application 
software;Electronic mail;Fault detection;Information 
filtering;Information filters;Logistics;Open source software;Postal 
services;Software quality;Unsolicited electronic mail},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228641&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228641&amp;isnumber=4228635</a><br><br>S. Minto and G. C. Murphy, "Recommending Emergent Teams," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 5-5.<br>doi: 10.1109/MSR.2007.27<br>Abstract:
 To build successful complex software systems, developers must 
collaborate with each other to solve issues. To facilitate this 
collaboration, specialized tools, such as chat and screen sharing, are 
being integrated into development environments. Currently, these tools 
require a developer to maintain a list of other developers with whom 
they may wish to communicate and to determine who within this list has 
expertise for a specific situation. For large, dynamic projects, like 
several successful open-source projects, these requirements place an 
unreasonable burden on the developer. In this paper, we show how the 
structure of a team emerges from how developers change software 
artifacts. We introduce the emergent expertise locator (EEL) that uses 
emergent team information to propose experts to a developer within their
 development environment as the developer works. We found that EEL 
produces, on average, results with higher precision and higher recall 
than an existing heuristic for expertise recommendation.<br> keywords: 
{project management;public domain software;software development 
management;team working;complex software system;emergent expertise 
locator;emergent team information;open-source project;software 
artifact;Collaborative software;Collaborative tools;Collaborative 
work;Data mining;Erbium;History;Java;Open source 
software;Programming;Software systems},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228642&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228642&amp;isnumber=4228635</a><br><br>C. Bird, A. Gourley, P. Devanbu, A. Swaminathan and G. Hsu, "Open Borders? Immigration in Open Source Projects," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 6-6.<br>doi: 10.1109/MSR.2007.23<br>Abstract:
 Open source software is built by teams of volunteers. Each project has a
 core team of developers, who have the authority to commit changes to 
the repository; this team is the elite, committed foundation of the 
project, selected through a meritocratic process from a larger number of
 people who participate on the mailing list. Most projects carefully 
regulate admission of outsiders to full developer privileges; some 
projects even have formal descriptions of this process. Understanding 
the factors that influence the "who, how and when" of this process is 
critical, both for the sustainability of FLOSS projects, and for outside
 stakeholders who want to gain entry and succeed. In this paper we mount
 a quantitative case study of the process by which people join FLOSS 
projects, using data mined from the Apache Web server, Postgres, and 
Python. We develop a theory of open source project joining, and evaluate
 this theory based on our data.<br> keywords: {public domain 
software;software engineering;FLOSS projects;meritocratic process;open 
source projects;open source software;Birds;Computer science;Data 
mining;Design engineering;Failure analysis;Hazards;Inhibitors;Open 
source software;Programming profession;Web server},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228643&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228643&amp;isnumber=4228635</a><br><br>O. Baysal and A. J. Malton, "Correlating Social Interactions to Release History during Software Evolution," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 7-7.<br>doi: 10.1109/MSR.2007.4<br>Abstract:
 In this paper, we propose a method to reason about the nature of 
software changes by mining and correlating discussion archives. We 
employ an information retrieval approach to find correlation between 
source code change history and history of social interactions 
surrounding these changes. We apply our correlation method on two 
software systems, LSEdit and Apache Ant. The results of these 
exploratory case studies demonstrate the evidence of similarity between 
the content of free-form text emails among developers and the actual 
modifications in the code. We identify a set of correlation patterns 
between discussion and changed code vocabularies and discover that some 
releases referred to as minor should instead fall under the major 
category. These patterns can be used to give estimations about the type 
of a change and time needed to implement it.<br> keywords: {information 
retrieval;interactive systems;public domain software;software 
prototyping;Apache Ant;LSEdit;correlation pattern;information 
retrieval;social interaction;software evolution;text email;Application 
software;Computer science;Correlation;Energy 
management;History;Information retrieval;Open source software;Power 
system management;Software systems;Vocabulary},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228644&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228644&amp;isnumber=4228635</a><br><br>L. Yu and S. Ramaswamy, "Mining CVS Repositories to Understand Open-Source Project Developer Roles," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 8-8.<br>doi: 10.1109/MSR.2007.19<br>Abstract:
 This paper presents a model to represent the interactions of 
distributed open-source software developers and utilizes data mining 
techniques to derive developer roles. The model is then applied on case 
studies of two open-source projects, ORAC-DR and Mediawiki with 
encouraging results.<br> keywords: {data mining;data 
warehouses;distributed programming;human factors;project 
management;public domain software;software development management;CVS 
repository mining;Mediawiki project;ORAC-DR project;data mining 
techniques;developer interactions;distributed open-source software 
developement;open-source project developer roles;Associate 
members;Cognitive science;Collaborative work;Computer science;Data 
mining;Frequency measurement;Informatics;Open source software;Software 
engineering;Software measurement},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228645&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228645&amp;isnumber=4228635</a><br><br>P. Weissgerber, M. Pohl and M. Burch, "Visual Data Mining in Software Archives to Detect How Developers Work Together," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 9-9.<br>doi: 10.1109/MSR.2007.34<br>Abstract:
 Analyzing the check-in information of open source software projects 
which use a version control system such as CVS or SUBVERSION can yield 
interesting and important insights into the programming behavior of 
developers. As in every major project tasks are assigned to many 
developers, the development must be coordinated between these 
programmers. This paper describes three visualization techniques that 
help to examine how programmers work together, e.g. if they work as a 
team or if they develop their part of the software separate from each 
other. Furthermore, phases of stagnation in the lifetime of a project 
can be uncovered and thus, possible problems are revealed. To 
demonstrate the usefulness of these visualization techniques we 
performed case studies on two open source projects. In these studies 
interesting patterns of developers' behavior, e.g. the specialization on
 a certain module can be observed. Moreover, modules that have been 
changed by many developers can be identified as well as such ones that 
have been altered by only one programmer.<br> keywords: {configuration 
management;data mining;data visualisation;information retrieval;public 
domain software;data visualisation technique;open source software 
project;software archive;version control system;visual data 
mining;Computer science;Control systems;Data mining;Data 
visualization;Frequency;Information analysis;Information 
retrieval;Mathematical programming;Open source software;Programming 
profession},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228646&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228646&amp;isnumber=4228635</a><br><br>C. Kiefer, A. Bernstein and J. Tappolet, "Mining Software Repositories with iSPAROL and a Software Evolution Ontology," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 10-10.<br>doi: 10.1109/MSR.2007.21<br>Abstract:
 One of the most important decisions researchers face when analyzing the
 evolution of software systems is the choice of a proper data 
analysis/exchange format. Most existing formats have to be processed 
with special programs written specifically for that purpose and are not 
easily extendible. Most scientists, therefore, use their own 
data-base(s) requiring each of them to repeat the work of writing the 
import/export programs to their format. We present EvoOnt, a software 
repository data exchange format based on the Web Ontology Language 
(OWL). EvoOnt includes software, release, and bug-related information. 
Since OWL describes the semantics of the data, EvoOnt is (1) easily 
extendible, (2) comes with many existing tools, and (3) allows to derive
 assertions through its inherent Description Logic reasoning 
capabilities. The paper also shows iSPARQL -our SPARQL-based Semantic 
Web query engine containing similarity joins. Together with EvoOnt, 
iSPARQL can accomplish a sizable number of tasks sought in software 
repository mining projects, such as an assessment of the amount of 
change between versions or the detection of bad code smells. To 
illustrate the usefulness of EvoOnt (and iSPARQL), we perform a series 
of experiments with a real-world Java project. These show that a number 
of software analyses can be reduced to simple iSPARQL queries on an 
EvoOnt dataset.<br> keywords: {configuration management;data 
analysis;data mining;database management systems;electronic data 
interchange;inference mechanisms;knowledge representation 
languages;ontologies (artificial intelligence);query languages;semantic 
Web;software prototyping;EvoOnt software repository data exchange 
format;Web Ontology Language;bug-related information;data analysis;data 
exchange format;database system;description logic 
reasoning;iSPARQL;import/export programs;semantic Web query 
engine;software evolution ontology;software release information;software
 version change;Data 
analysis;Databases;Engines;Informatics;Logic;OWL;Ontologies;Semantic 
Web;Software systems;Software tools},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228647&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228647&amp;isnumber=4228635</a><br><br>T. Zimmermann, "Mining Workspace Updates in CVS," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 11-11.<br>doi: 10.1109/MSR.2007.22<br>Abstract:
 The version control archive CVS records not only all changes in a 
project but also activity data such as when developers create or update 
their workspaces. Furthermore, CVS records when it has to integrate 
changes because of parallel development. In this paper, we analyze the 
CVS activity data of four large open-source projects CCC, JBOSS, JEDIT, 
and PYTHON to investigate parallel development: What is the degree of 
parallel development? How frequently do conflicts occur during updates 
and how are they resolved? How do we identify changes that contain 
integrations?<br> keywords: {configuration management;data 
mining;parallel programming;public domain software;software 
engineering;open-source project;parallel development;version control 
archive CVS record;workspace update mining;Application 
software;Automatic control;Computer science;Control systems;History;Open
 source software;Terminology},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228648&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228648&amp;isnumber=4228635</a><br><br>M. Grechanik, K. M. Conroy and K. A. Probst, "Finding Relevant Applications for Prototyping," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 12-12.<br>doi: 10.1109/MSR.2007.9<br>Abstract:
 When gathering requirements for new software projects, it is often 
cost-effective to find similar applications that can be used as the 
basis for prototypes rather than building them from scratch. However, 
finding such sample applications can be difficult, often making 
prototyping time-consuming and expensive. We offer a novel approach 
called Exemplar (EXEcutable exaMPLes ARchive) for finding highly 
relevant software projects from a large archive of executable 
applications. After a programmer enters a query that contains high-level
 concepts (e.g., toolbar, download, smart card), Exemplar uses 
information retrieval and program analysis to retrieve applications that
 implement these concepts. We hypothesize that Exemplar will be 
effective and efficient in helping programmers to quickly find highly 
relevant applications to support prototyping.<br> keywords: {formal 
specification;information retrieval;program diagnostics;project 
management;software development management;software 
prototyping;executable examples archive;high-level concept;information 
retrieval;program analysis;software project;software 
prototyping;Application software;Feedback;Information 
analysis;Information retrieval;Open source software;Programming 
profession;Prototypes;Search engines;Smart cards;Software prototyping},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228649&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228649&amp;isnumber=4228635</a><br><br>S. P. Masticola, "Lightweight Risk Mitigation for Software Development Projects Using Repository Mining," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 13-13.<br>doi: 10.1109/MSR.2007.16<br>Abstract:
 Many software projects fail to deliver their needed results on-time and
 on-budget. There are a variety of reasons why this may occur. For some 
of these reasons (notably deterioration of the codebase), corrective 
action is often difficult to cost-justify or to implement efficiently in
 practice. To address this, an approach of lightweight risk mitigation 
is proposed: mine risk data from configuration management and defect 
tracking systems, integrate this data with project-cost data in a 
flexible dashboard, and facilitate strategic refactoring with 
semi-custom transforms where necessary. This prescriptive information 
would simultaneously help the project manager to cost-justify repair 
efforts and lowers the cost of finding and fixing hot spots.<br> 
keywords: {configuration management;data mining;project management;risk 
analysis;software engineering;software management;configuration 
management;defect tracking system;flexible dashboard;lightweight risk 
mitigation;repository mining;risk data mining;semi-custom 
transform;software development projects;Costs;Data mining;Educational 
institutions;Large-scale systems;Programming;Project 
management;Protection;Real time systems;Risk management;Software 
maintenance},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228650&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228650&amp;isnumber=4228635</a><br><br>G. Canfora, L. Cerulo and M. D. Penta, "Identifying Changed Source Code Lines from Version Repositories," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 14-14.<br>doi: 10.1109/MSR.2007.14<br>Abstract:
 Observing the evolution of software systems at different levels of 
granularity has been a key issue for a number of studies, aiming at 
predicting defects or at studying certain phenomena, such as the 
presence of clones or of crosscutting concerns. Versioning systems such 
as CVS and SVN, however, only provide information about lines added or 
deleted by a contributor: any change is shown as a sequence of additions
 and deletions. This provides an erroneous estimate of the amount of 
code changed. This paper shows how the evolution of changes at source 
code line level can be inferred from CVS repositories, by combining 
information retrieval techniques and the Levenshtein edit distance. The 
application of the proposed approach to the ArgoUML case study indicates
 a high precision and recall.<br> keywords: {configuration 
management;information retrieval;software prototyping;software 
reusability;ArgoUML snapshot;concurrent versioning system;crosscutting 
concern;information retrieval;software evolution system;source code 
lines;Cloning;Collaborative software;Collaborative work;Information 
analysis;Information retrieval;Lab-on-a-chip;Software systems},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228651&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228651&amp;isnumber=4228635</a><br><br>R. Robbes, "Mining a Change-Based Software Repository," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 15-15.<br>doi: 10.1109/MSR.2007.18<br>Abstract:
 Although state-of-the-art software repositories based on versioning 
system information are useful to assess the evolution of a software 
system, the information they contain is limited in several ways. 
Versioning systems such as CVS or subversion store only snapshots of 
text files, leading to a loss of information: The exact sequence of 
changes between two versions is hard to recover. In this paper we 
present an alternative information repository which stores incremental 
changes to the system under study, retrieved from the IDE used to build 
the software. We then use this change-based model of system evolution to
 assess when refactorings happen in two case studies, and compare our 
findings with refactoring detection approaches on classical versioning 
system repositories.<br> keywords: {configuration management;data 
mining;software maintenance;software prototyping;change-based software 
repository;data mining;information repository;software 
evolution;software refactoring;versioning system information;Application
 software;Concrete;Degradation;Frequency;Informatics;Information 
retrieval;Sampling methods;Software design;Software performance;Software
 systems},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228652&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228652&amp;isnumber=4228635</a><br><br>F. V. Rysselberghe and S. Demeyer, "Studying Versioning Information to Understand Inheritance Hierarchy Changes," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 16-16.<br>doi: 10.1109/MSR.2007.30<br>Abstract:
 With the widespread adoption of object-oriented programming, changing 
the inheritance hierarchy became an inherent part of today's software 
maintenance activities. Unfortunately, little is known about the 
"state-of-the-practice " with respect to changing an application's 
inheritance hierarchy, and consequently we do not know how the change 
process can be improved. In this paper, we report on a study of the 
hierarchy changes stored in a versioning system to explore the answers 
to three research questions: (1) why are hierarchy changes made? (2) 
what kind of hierarchy changes are made? (3) what is the impact of these
 changes? Based on the results of this study, we formulate 7 hypotheses 
which should be investigated further to make conclusive interpretations 
on how hierarchy changes fit in the actual change process.<br> keywords:
 {configuration management;inheritance;object-oriented 
programming;software maintenance;application inheritance hierarchy 
change;object-oriented programming;software maintenance 
activity;versioning system;Computer languages;Data 
mining;History;Java;Manuals;Object oriented modeling;Object oriented 
programming;Software maintenance;Software systems;Testing},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228653&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228653&amp;isnumber=4228635</a><br><br>H. Kagdi and J. I. Maletic, "Combining Single-Version and Evolutionary Dependencies for Software-Change Prediction," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 17-17.<br>doi: 10.1109/MSR.2007.2<br>Abstract:
 The paper advocates the need for the investigation and development of a
 software-change prediction methodology that combines the change sets 
estimated from software dependency analysis (via single-version 
analysis) and the actual change sets found in software version histories
 (via multiple-version analysis). Traditionally prescribed methodologies
 such as Impact Analysis (IA) are based on the former, whereas a more 
recent methodology, mining software repository (MSR), is based on the 
latter. The research hypothesis is that combining these two 
methodologies will result in an overall improved support for 
software-change prediction.<br> keywords: {configuration management;data
 mining;data warehouses;management of change;software development 
management;MSR method;change sets;evolutionary dependencies;mining 
software repository;multiple-version analysis;single-version 
analysis;software dependency analysis;software version 
histories;software-change prediction;Collaborative 
software;Computational efficiency;Computer science;History;Open source 
software;Performance analysis;Software performance;Software 
systems;State estimation;Unified modeling language},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228654&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228654&amp;isnumber=4228635</a><br><br>A. Lozano, M. Wermelinger and B. Nuseibeh, "Evaluating the Harmfulness of Cloning: A Change Based Experiment," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 18-18.<br>doi: 10.1109/MSR.2007.8<br>Abstract:
 Cloning is considered a harmful practice for software maintenance 
because it requires consistent changes of the entities that share a 
cloned fragment. However this claim has not been refuted or confirmed 
empirically. Therefore, we have developed a prototype tool, 
CloneTracker, in order to study the rate of change of applications 
containing clones. This paper describes CloneTracker and illustrates its
 preliminary application on a case study.<br> keywords: {configuration 
management;program diagnostics;software maintenance;software 
prototyping;CloneTracker;prototype tool;software maintenance;Application
 software;Cloning;Degradation;Java;Kernel;Linux;Prototypes;Software 
maintenance;Software prototyping;Telecommunications},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228655&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228655&amp;isnumber=4228635</a><br><br>A. Hindle, M. W. Godfrey and R. C. Holt, "Release Pattern Discovery via Partitioning: Methodology and Case Study," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 19-19.<br>doi: 10.1109/MSR.2007.28<br>Abstract:
 The development of Open Source systems produces a variety of software 
artifacts such as source code, version control records, bug reports, and
 email discussions. Since the development is distributed across 
different tool environments and developer practices, any analysis of 
project behavior must be inferred from whatever common artifacts happen 
to be available. In this paper, we propose an approach to characterizing
 a project's behavior around the time of major and minor releases; we do
 this by partitioning the observed activities, such as artifact 
check-ins, around the dates of major and minor releases, and then look 
for recognizable patterns. We validate this approach by means of a case 
study on the MySQL database system; in this case study, we found 
patterns which suggested MySQL was behaving consistently within itself. 
These patterns included testing and documenting that took place more 
before a release than after and that the rate of source code changes 
dipped around release time.<br> keywords: {SQL;public domain 
software;software architecture;MySQL database system;artifact 
check-ins;open source system;software artifacts;source code;Capability 
maturity model;Control systems;Data analysis;Data mining;Open source 
software;Programming;Software measurement;Software tools;Testing;Time 
measurement},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228656&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228656&amp;isnumber=4228635</a><br><br>H. Kagdi, M. L. Collard and J. I. Maletic, "Comparing Approaches to Mining Source Code for Call-Usage Patterns," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 20-20.<br>doi: 10.1109/MSR.2007.3<br>Abstract:
 Two approaches for mining function-call usage patterns from source code
 are compared The first approach, itemset mining, has recently been 
applied to this problem. The other approach, sequential-pattern mining, 
has not been previously applied to this problem. Here, a call-usage 
pattern is a composition of function calls that occur in a function 
definition. Both approaches look for frequently occurring patterns that 
represent standard usage of functions and identify possible errors. 
Itemset mining produces unordered patterns, i.e., sets of function 
calls, whereas, sequential-pattern mining produces partially ordered 
patterns, i.e., sequences of function calls. The trade-off between the 
additional ordering context given by sequential-pattern mining and the 
efficiency of itemset mining is investigated. The two approaches are 
applied to the Lima kernel v2.6.14 and results show that mining ordered 
patterns is worth the additional cost.<br> keywords: {data 
mining;software engineering;Lima kernel v2.6.14;call-usage 
pattern;itemset mining;sequential-pattern mining;software 
engineering;source code;Computational efficiency;Computer 
science;Costs;Data mining;Fault 
diagnosis;Inspection;Itemsets;Kernel;Linux;Software systems},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228657&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228657&amp;isnumber=4228635</a><br><br>I. Herraiz, J. M. Gonzalez-Barahona and G. Robles, "Towards a Theoretical Model for Software Growth," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 21-21.<br>doi: 10.1109/MSR.2007.31<br>Abstract:
 Software growth (and more broadly, software evolution) is usually 
considered in terms of size or complexity of source code. However in 
different studies, usually different metrics are used, which make it 
difficult to compare approaches and results. In addition, not all 
metrics are equally easy to calculate for a given source code, which 
leads to the question of which one is the easiest to calculate without 
losing too much information. To address both issues, in this paper 
present a comprehensive study, based on the analysis of about 700,000 C 
source code files, calculating several size and complexity metrics for 
all of them. For this sample, we have found double Pareto statistical 
distributions for all metrics considered, and a high correlation between
 any two of them. This would imply that any model addressing software 
growth should produce this Pareto distributions, and that analysis based
 on any of the considered metrics should show a similar pattern, 
provided the sample of files considered is large enough.<br> keywords: 
{C language;Pareto distribution;correlation methods;program 
diagnostics;software metrics;software prototyping;C source code file 
analysis;Pareto statistical distribution;correlation method;software 
evolution;software growth model;source code complexity metrics;source 
code size metrics;Licenses;Linux;Open source software;Packaging;Pareto 
analysis;Pattern analysis;Software engineering;Software 
measurement;Statistical analysis;Statistical distributions},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228658&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228658&amp;isnumber=4228635</a><br><br>S. Livieri, Y. Higo, M. Matsushita and K. Inoue, "Analysis of the Linux Kernel Evolution Using Code Clone Coverage," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 22-22.<br>doi: 10.1109/MSR.2007.1<br>Abstract:
 Most studies of the evolution of software systems are based on the 
comparison of simple software metrics. In this paper, we present our 
preliminary investigation of the evolution of the Linux kernel using 
code-clone analysis and the code-clone coverage metrics. We examined 136
 versions of the stable Linux kernel using a distributed extension of 
the code clone detection tool CCFinder. The result is shown as a heat 
map.<br> keywords: {Linux;operating system kernels;software 
metrics;Linux kernel evolution;code clone detection tool;software 
metrics;Cloning;Information analysis;Information 
science;Kernel;Large-scale systems;Linux;Performance analysis;Software 
metrics;Software systems;Vehicles},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228659&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228659&amp;isnumber=4228635</a><br><br>P.
 C. Rigby and A. E. Hassan, "What Can OSS Mailing Lists Tell Us? A 
Preliminary Psychometric Text Analysis of the Apache Developer Mailing 
List," <em>Mining Software Repositories, 2007. ICSE Workshops MSR '07. Fourth International Workshop on</em>, Minneapolis, MN, 2007, pp. 23-23.<br>doi: 10.1109/MSR.2007.35<br>Abstract:
 Developer mailing lists are a rich source of information about Open 
Source Software (OSS) development. The unstructured nature of email 
makes extracting information difficult. We use a psychometrically-based 
linguistic analysis tool, the LIWC, to examine the Apache httpd server 
developer mailing list. We conduct three preliminary experiments to 
assess the appropriateness of this tool for information extraction from 
mailing lists. First, using LIWC dimensions that are correlated with the
 big five personality traits, we assess the personality of four top 
developers against a baseline for the entire mailing list. The two 
developers that were responsible for the major Apache releases had 
similar personalities. Their personalities were different from the 
baseline and the other developers. Second, the first and last 50 emails 
for two top developers who have left the project are examined. The 
analysis shows promise in understanding why developers join and leave a 
project. Third, we examine word usage on the mailing list for two major 
Apache releases. The differences may reflect the relative success of 
each release.<br> keywords: {electronic mail;public domain 
software;software engineering;text analysis;Apache developer mailing 
list;email;information extraction;open source software development;open 
source software mailing lists;psychometric text 
analysis;psychometrically-based linguistic analysis;Data 
mining;Databases;Dictionaries;Information resources;Machine 
learning;Open source software;Psychology;Software engineering;Text 
analysis;Web server},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228660&amp;isnumber=4228635">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4228660&amp;isnumber=4228635</a><br><br>
</body></html>