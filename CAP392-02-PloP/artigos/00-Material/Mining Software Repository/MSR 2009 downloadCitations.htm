<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"></head><body>"Welcome," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. c1-c1.<br>doi: 10.1109/MSR.2009.5069459<br>Abstract:
 The following topics are dealt with: version control systems; defect 
prediction; text analysis; mining software repositories; topic mining; 
and software development.<br> keywords: {data mining;software 
engineering;text analysis;defect prediction;mining software 
repositories;software development;text analysis;topic mining;version 
control systems},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069459&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069459&amp;isnumber=5069458</a><br><br>"Hub page," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-1.<br>doi: 10.1109/MSR.2009.5069460<br>Abstract: Presents the proceedings page that links various sections of the overall electronic record.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069460&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069460&amp;isnumber=5069458</a><br><br>"Session list," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-1.<br>doi: 10.1109/MSR.2009.5069461<br>Abstract: Provides a schedule of conference events and a listing of which papers were presented in each session.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069461&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069461&amp;isnumber=5069458</a><br><br>"Table of contents," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-4.<br>doi: 10.1109/MSR.2009.5069462<br>Abstract: Presents the table of contents of the proceedings.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069462&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069462&amp;isnumber=5069458</a><br><br>"Brief author index," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-3.<br>doi: 10.1109/MSR.2009.5069463<br>Abstract: Presents an index of the authors whose papers are published in the conference.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069463&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069463&amp;isnumber=5069458</a><br><br>"Detailed author index," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-11.<br>doi: 10.1109/MSR.2009.5069464<br>Abstract: Presents an index of the authors whose papers are published in the conference.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069464&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069464&amp;isnumber=5069458</a><br><br>"The end of indexes," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-1.<br>doi: 10.1109/MSR.2009.5069465<br>Abstract: You have reached the end of this document.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069465&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069465&amp;isnumber=5069458</a><br><br>"[PDF Reader FAQ and support]," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-1.<br>doi: 10.1109/MSR.2009.5069466<br>Abstract: Provides instructions on viewing the proceedings articles in PDF format and support information for CD users.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069466&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069466&amp;isnumber=5069458</a><br><br>"[PDF Reader FAQ and support]," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-4.<br>doi: 10.1109/MSR.2009.5069467<br>Abstract: Provides instructions on viewing the proceedings articles in PDF format and support information for CD users.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069467&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069467&amp;isnumber=5069458</a><br><br>"Release," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-1.<br>doi: 10.1109/MSR.2009.5069468<br>Abstract: Provides instructions on viewing the proceedings articles in PDF format and support information for CD users.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069468&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069468&amp;isnumber=5069458</a><br><br>"[Title page]," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-1.<br>doi: 10.1109/MSR.2009.5069469<br>Abstract: Conference proceedings title page.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069469&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069469&amp;isnumber=5069458</a><br><br>"Welcome from the chairs," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-2.<br>doi: 10.1109/MSR.2009.5069470<br>Abstract: Presents the welcome message from the conference proceedings.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069470&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069470&amp;isnumber=5069458</a><br><br>"MSR 2009 Organizing Committee," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-1.<br>doi: 10.1109/MSR.2009.5069471<br>Abstract: Provides a listing of current committee members.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069471&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069471&amp;isnumber=5069458</a><br><br>"MSR-09 Program Committee," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-2.<br>doi: 10.1109/MSR.2009.5069472<br>Abstract: Provides a listing of current committee members.<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069472&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069472&amp;isnumber=5069458</a><br><br>M. McAllister, "Success factors of Business Intelligence," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-1.<br>doi: 10.1109/MSR.2009.5069473<br>Abstract:
 Business Intelligence (BI) has proven to be a competitive advantage for
 organizations, allowing them to better measure, manage, and optimize 
their operations. It has provided the means to improve data-driven 
decision making and to harmonize an organization's strategy with its 
everyday operations. The early success of BI arose in providing a 
semantic-level access to heterogeneous data sources beyond 
organizations' information technology departments. Retrospective and 
predictive analytical components have since increased the value of BI to
 the organizations. In this talk, we will discuss success factors and 
influences for BI that have arisen by making information available 
across an organization and will open a discussion on some of the 
near-term and long-term BI challenges.<br> keywords: {business data 
processing;competitive intelligence;organisational aspects;business 
intelligence;data-driven decision making;semantic-level access;success 
factor;Acceleration;Biographies;Bismuth;Competitive 
intelligence;Computer science;Decision making;Helium;Information 
technology;North America;Project management},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069473&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069473&amp;isnumber=5069458</a><br><br>T. Ball, "A brief history of software â€” from Bell Labs to Microsoft Research," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-1.<br>doi: 10.1109/MSR.2009.5069474<br>Abstract:
 In the mid 1990s, I was (tangentially) part of an effort in Bell Labs 
called the "Code Decay" project. The hypothesis of this project was that
 over time code becomes fragile (more difficult to change without 
introducing problems), and that this process of decay could be 
empirically validated. This effort awakened me to the power of combining
 statistical expertise with software engineering expertise to address 
pressing problems of software production in a statistically valid 
manner. I will revisit some of the work we did in the Code Decay project
 at Bell Labs and then turn to what has been happening in this area in 
Microsoft in the last five years. In particular, I will trace how we 
have progressed from studying the data produced by product teams to 
validate hypotheses, to being actively involved with the product groups 
in creating and evaluating new tools and techniques for 
empirically-based software production.<br> keywords: {software 
maintenance;statistical analysis;Bell Labs;Microsoft Research;code decay
 project;empirically-based software production;fragile code change 
management;software engineering;statistical hypotheses 
validation;Automatic 
testing;Biographies;Engines;History;Pressing;Production;Simultaneous 
localization and mapping;Software engineering;Software 
reliability;Software tools},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069474&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069474&amp;isnumber=5069458</a><br><br>C. Bird, P. C. Rigby, E. T. Barr, D. J. Hamilton, D. M. German and P. Devanbu, "The promises and perils of mining git," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 1-10.<br>doi: 10.1109/MSR.2009.5069475<br>Abstract:
 We are now witnessing the rapid growth of decentralized source code 
management (DSCM) systems, in which every developer has her own 
repository. DSCMs facilitate a style of collaboration in which work 
output can flow sideways (and privately) between collaborators, rather 
than always up and down (and publicly) via a central repository. 
Decentralization comes with both the promise of new data and the peril 
of its misinterpretation. We focus on git, a very popular DSCM used in 
high-profile projects. Decentralization, and other features of git, such
 as automatically recorded contributor attribution, lead to richer 
content histories, giving rise to new questions such as ldquoHow do 
contributions flow between developers to the official project 
repository?rdquo However, there are pitfalls. Commits may be reordered, 
deleted, or edited as they move between repositories. The semantics of 
terms common to SCMs and DSCMs sometimes differ markedly, potentially 
creating confusion. For example, a commit is immediately visible to all 
developers in centralized SCMs, but not in DSCMs. Our goal is to help 
researchers interested in DSCMs avoid these and other perils when mining
 and analyzing git data.<br> keywords: {data analysis;data 
mining;groupware;automatically recorded contributor attribution;central 
repository;collaboration;data analysis;decentralization;decentralized 
source code management systems;mining git;Birds;Collaborative work;Data 
analysis;History;Kernel;Linux;Mercury (metals);Open source 
software;Packaging;Rails},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069475&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069475&amp;isnumber=5069458</a><br><br>A. Mockus, "Amassing and indexing a large sample of version control systems: Towards the census of public source code history," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 11-20.<br>doi: 10.1109/MSR.2009.5069476<br>Abstract:
 The source code and its history represent the output and process of 
software development activities and are an invaluable resource for study
 and improvement of software development practice. While individual 
projects and groups of projects have been extensively analyzed, some 
fundamental questions, such as the spread of innovation or genealogy of 
the source code, can be answered only by considering the entire universe
 of publicly available source code and its history. We describe methods 
we developed over the last six years to gather, index, and update an 
approximation of such a universal repository for publicly accessible 
version control systems and for the source code inside a large 
corporation. While challenging, the task is achievable with limited 
resources. The bottlenecks in network bandwidth, processing, and disk 
access can be dealt with using inherent parallelism of the tasks and 
suitable tradeoffs between the amount of storage and computations, but a
 completely automated discovery of public version control systems may 
require enticing participation of the sampled projects. Such universal 
repository would allow studies of global properties and origins of the 
source code that are not possible through other means.<br> keywords: 
{configuration management;data mining;database indexing;public domain 
software;software maintenance;automated knowledge discovery;disk 
access;network bandwidth;public source code history;public version 
control system indexing;software development activity;source code 
evolution;task parallelism;universal software 
repository;Bandwidth;Computer networks;Concurrent computing;Control 
systems;History;Indexing;Parallel processing;Programming;Storage 
automation;Technological innovation},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069476&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069476&amp;isnumber=5069458</a><br><br>Weiyi
 Shang, Zhen Ming Jiang, B. Adams and A. E. Hassan, "MapReduce as a 
general framework to support research in Mining Software Repositories 
(MSR)," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 21-30.<br>doi: 10.1109/MSR.2009.5069477<br>Abstract:
 Researchers continue to demonstrate the benefits of Mining Software 
Repositories (MSR) for supporting software development and research 
activities. However, as the mining process is time and resource 
intensive, they often create their own distributed platforms and use 
various optimizations to speed up and scale up their analysis. These 
platforms are project-specific, hard to reuse, and offer minimal 
debugging and deployment support. In this paper, we propose the use of 
MapReduce, a distributed computing platform, to support research in MSR.
 As a proof-of-concept, we migrate J-REX, an optimized evolutionary code
 extractor, to run on Hadoop, an open source implementation of 
MapReduce. Through a case study on the source control repositories of 
the Eclipse, BIRT and Datatools projects, we demonstrate that the 
migration effort to MapReduce is minimal and that the benefits are 
significant, as running time of the migrated J-REX is only 30% to 50% of
 the original J-REX's. This paper documents our experience with the 
migration, and highlights the benefits and challenges of the MapReduce 
framework in the MSR community.<br> keywords: {data mining;distributed 
algorithms;distributed programming;evolutionary computation;public 
domain software;software engineering;Hadoop open source platform;J-REX 
optimized evolutionary code extractor;MapReduce framework;distributed 
computing;mining software repository;software debugging;software 
development;Data mining;Debugging;Distributed 
computing;Kernel;Linux;Programming;Scalability;Software 
performance;Software systems;Workstations},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069477&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069477&amp;isnumber=5069458</a><br><br>G. Gousios and D. Spinellis, "A platform for software engineering research," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 31-40.<br>doi: 10.1109/MSR.2009.5069478<br>Abstract:
 Research in the fields of software quality, maintainability and 
evolution requires the analysis of large quantities of data, which often
 originate from open source software projects. Collecting and 
preprocessing data, calculating metrics, and synthesizing composite 
results from a large corpus of project artifacts is a tedious and error 
prone task lacking direct scientific value. The Alitheia Core tool is an
 extensible platform for software quality analysis that is designed 
specifically to facilitate software engineering research on large and 
diverse data sources, by integrating data collection and preprocessing 
phases with an array of analysis services, and presenting the researcher
 with an easy to use extension mechanism. Alitheia Core aims to be the 
basis of an ecosystem of shared tools and research data that will enable
 researchers to focus on their research questions at hand, rather than 
spend time on re-implementing analysis tools. In this paper, we present 
the Alitheia Core platform in detail and demonstrate its usefulness in 
mining software repositories by guiding the reader through the steps 
required to execute a simple experiment.<br> keywords: {data 
mining;public domain software;software maintenance;software 
quality;Alitheia Core tool;data collection;data preprocessing;open 
source software project;software engineering research;software 
evolution;software maintainability;software quality analysis;software 
repository mining;Control systems;Ecosystems;Large-scale systems;Open 
source software;Phased arrays;Project management;Quality 
management;Software engineering;Software quality;Standardization},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069478&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069478&amp;isnumber=5069458</a><br><br>C.
 Boogerd and L. Moonen, "Evaluating the relation between coding standard
 violations and faultswithin and across software versions," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 41-50.<br>doi: 10.1109/MSR.2009.5069479<br>Abstract:
 In spite of the widespread use of coding standards and tools enforcing 
their rules, there is little empirical evidence supporting the intuition
 that they prevent the introduction of faults in software. In previous 
work, we performed a pilot study to assess the relation between rule 
violations and actual faults, using the MISRA C 2004 standard on an 
industrial case. In this paper, we investigate three different aspects 
of the relation between violations and faults on a larger case study, 
and compare the results across the two projects. We find that 10 rules 
in the standard are significant predictors of fault location.<br> 
keywords: {software fault tolerance;MISRA C 2004 standard;coding 
standard violations;fault location;software faults;software 
versions;Code standards;Fault location;Industrial 
relations;Inspection;Laboratories;Maintenance;Software quality;Software 
standards;Software tools;Standards development},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069479&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069479&amp;isnumber=5069458</a><br><br>J.
 Ekanayake, J. Tappolet, H. C. Gall and A. Bernstein, "Tracking concept 
drift of software projects using defect prediction quality," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 51-60.<br>doi: 10.1109/MSR.2009.5069480<br>Abstract:
 Defect prediction is an important task in the mining of software 
repositories, but the quality of predictions varies strongly within and 
across software projects. In this paper we investigate the reasons why 
the prediction quality is so fluctuating due to the altering nature of 
the bug (or defect) fixing process. Therefore, we adopt the notion of a 
concept drift, which denotes that the defect prediction model has become
 unsuitable as set of influencing features has changed - usually due to a
 change in the underlying bug generation process (i.e., the concept). We
 explore four open source projects (Eclipse, OpenOffice, Netbeans and 
Mozilla) and construct file-level and project-level features for each of
 them from their respective CVS and Bugzilla repositories. We then use 
this data to build defect prediction models and visualize the prediction
 quality along the time axis. These visualizations allow us to identify 
concept drifts and - as a consequence - phases of stability and 
instability expressed in the level of defect prediction quality. 
Further, we identify those project features, which are influencing the 
defect prediction quality using both a tree induction-algorithm and a 
linear regression model. Our experiments uncover that software systems 
are subject to considerable concept drifts in their evolution history. 
Specifically, we observe that the change in number of authors editing a 
file and the number of defects fixed by them contribute to a project's 
concept drift and therefore influence the defect prediction quality. Our
 findings suggest that project managers using defect prediction models 
for decision making should be aware of the actual phase of stability or 
instability due to a potential concept drift.<br> keywords: {data 
mining;decision making;decision trees;program debugging;program 
testing;project management;regression analysis;software 
maintenance;Bugzilla 
repository;CVS;Eclipse;Mozilla;Netbeans;OpenOffice;bug generation 
process;concept drift tracking;decision making;decision tree 
induction-algorithm;defect prediction quality visualization;linear 
regression model;open source project;software bug fixing 
process;software project management;software repository mining;software 
system evolution history;software testing;Computer architecture;Computer
 bugs;Data visualization;History;Insulation life;Prediction 
algorithms;Predictive models;Software quality;Software 
systems;Stability},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069480&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069480&amp;isnumber=5069458</a><br><br>Y. Shin, R. Bell, T. Ostrand and E. Weyuker, "Does calling structure information improve the accuracy of fault prediction?," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 61-70.<br>doi: 10.1109/MSR.2009.5069481<br>Abstract:
 Previous studies have shown that software code attributes, such as 
lines of source code, and history information, such as the number of 
code changes and the number of faults in prior releases of software, are
 useful for predicting where faults will occur. In this study of an 
industrial software system, we investigate the effectiveness of adding 
information about calling structure to fault prediction models. The 
addition of calling structure information to a model based solely on 
non-calling structure code attributes provided noticeable improvement in
 prediction accuracy, but only marginally improved the best model based 
on history and non-calling structure code attributes. The best model 
based on history and non-calling structure code attributes outperformed 
the best model based on calling and non-calling structure code 
attributes.<br> keywords: {software fault tolerance;software 
houses;calling structure information;fault prediction accuracy;history 
information;industrial software system;noncalling structure code 
attribute;Accuracy;Computer industry;Computer science;Costs;Fault 
diagnosis;History;Information analysis;Performance analysis;Predictive 
models;Software systems},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069481&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069481&amp;isnumber=5069458</a><br><br>E.
 Enslen, E. Hill, L. Pollock and K. Vijay-Shanker, "Mining source code 
to automatically split identifiers for software analysis," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 71-80.<br>doi: 10.1109/MSR.2009.5069482<br>Abstract:
 Automated software engineering tools (e.g., program search, concern 
location, code reuse, quality assessment, etc.) increasingly rely on 
natural language information from comments and identifiers in code. The 
first step in analyzing words from identifiers requires splitting 
identifiers into their constituent words. Unlike natural languages, 
where space and punctuation are used to delineate words, identifiers 
cannot contain spaces. One common way to split identifiers is to follow 
programming language naming conventions. For example, Java programmers 
often use camel case, where words are delineated by uppercase letters or
 non-alphabetic characters. However, programmers also create identifiers
 by concatenating sequences of words together with no discernible 
delineation, which poses challenges to automatic identifier splitting. 
In this paper, we present an algorithm to automatically split 
identifiers into sequences of words by mining word frequencies in source
 code. With these word frequencies, our identifier splitter uses a 
scoring technique to automatically select the most appropriate 
partitioning for an identifier. In an evaluation of over 8000 
identifiers from open source Java programs, our Samurai approach 
outperforms the existing state of the art techniques.<br> keywords: 
{data mining;program diagnostics;software maintenance;automatic split 
identifier;software analysis;software maintenance;source code 
mining;word frequency mining;Frequency;Information analysis;Java;Natural
 languages;Open source software;Programming profession;Quality 
assessment;Software maintenance;Software quality;Software tools},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069482&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069482&amp;isnumber=5069458</a><br><br>D.
 M. German, M. Di Penta, Y. G. Gueheneuc and G. Antoniol, "Code 
siblings: Technical and legal implications of copying code between 
applications," <em>Mining Software Repositories, 2009. MSR '09. 6th IEEE International Working Conference on</em>, Vancouver, BC, 2009, pp. 81-90.<br>doi: 10.1109/MSR.2009.5069483<br>Abstract:
 Source code cloning does not happen within a single system only. It can
 also occur between one system and another. We use the term code sibling
 to refer to a code clone that evolves in a different system than the 
code from which it originates. Code siblings can only occur when the 
source code copyright owner allows it and when the conditions imposed by
 such license are not incompatible with the license of the destination 
system. In some situations copying of source code fragments are allowed -
 legally - in one direction, but not in the other. In this paper, we use
 clone detection, license mining and classification, and change history 
techniques to understand how code siblings - under different licenses - 
flow in one direction or the other between Linux and two BSD Unixes, 
FreeBSD and OpenBSD. Our results show that, in most cases, this 
migration appears to happen according to the terms of the license of the
 original code being copied, favoring always copying from less 
restrictive licenses towards more restrictive ones. We also discovered 
that sometimes code is inserted to the kernels from an outside source.<br>
 keywords: {Linux;source coding;BSD Unixes;FreeBSD;Linux;OpenBSD;clone 
detection;code siblings;license mining;source code cloning;source code 
fragments;Cloning;Hardware;History;Kernel;Law;Legal 
factors;Licenses;Linux;Robustness;Software debugging;Code 
licensing;clone detection;software evolution},<br>URL:&nbsp;<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069483&amp;isnumber=5069458">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5069483&amp;isnumber=5069458</a><br><br>
</body></html>